---
layout: post
title: "[프로그래머스] 짝지어 제거하기"
date: 2021-05-27 23:33 +0530
categories: 프로그래머스 2017팁스다운
---

알고리즘 풀기 222일차

:)

- # 짝지어 제거하기
  >

## < 문제 >

짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다.

그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다.

이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다.

문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

    예를 들어, 문자열 S = baabaa 라면

    b aa baa → bb aa → aa →

    의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.

## < 제한사항 >

문자열의 길이 : 1,000,000이하의 자연수

문자열은 모두 소문자로 이루어져 있습니다.

## < 풀이 >

```python

def solution(s):
    stack = [s[0]]
    i = 1
    while i<len(s):
        stack.append(s[i])
        if len(stack)>1 and stack[-1] == stack[-2]:
            stack.pop()
            stack.pop()
        i+=1
    if not stack:
        return 1
    else:
        return 0

```

```python
# 시간초과

def solution(s):
    answer = -1
    i = 0

    while s:
        if i == len(s)-1:
            return 0

        if s[i] == s[i+1]:
            s = s[:i]+s[i+2:]
            i = 0
        else:
            i+=1

    return 1

```

맨 처음에 생각했던 거는 두 개씩 검사하여 같으면 두 문자 제거하고(문자열 컨버팅) 다시 인덱스 0부터 두자리 검사하는 로직을 생각했다.

그래서 문자열이 다 사라지면 1 리턴, 안사라지면 0을 리턴하게 하였다. 시간초과가 와방~ 났다.

그래서 도대체 뭐로 해야 시간을 줄일 수 있을까. 뭔가 스택의 pop으로 뺄 수 있는 방법을 생각하다 위의 코드를 생각하게 되었다.

우선 s 글자 하나하나 stack에 넣는데 가장 위의 두개가 같다면 2개를 빼면 된다. (쏘 씸플)

만약 끝났는데 stack에 남은게 있다면 0 리턴.

다른 사람의 풀이를 보니 나는 일단 append하고 맨 뒤에 두개를 비교하고 2개를 pop하는데, 해당 인덱스 i를 append하지 않고 s[i]와 stack[-1]를 비교하면 된다.

이런 사소한 생각으로 실력,,,이 드러나는 건가,,,
