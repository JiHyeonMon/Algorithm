---
layout: post
title: "[백준] RGB거리"
date: 2021-05-18 23:33 +0530
categories: 백준, 1149, 동적계획법
---

알고리즘 풀기 220일차

:)

- # RGB거리
  >

## < 문제 >

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번 집의 색과 같지 않아야 한다.

N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.

i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

## < 풀이 >

```python

import sys

RGB = []
n = int(sys.stdin.readline())

for i in range(n):
    RGB.append(list(map(int, sys.stdin.readline().split(' '))))

for i in range(1, n):
    RGB[i] = [min(RGB[i-1][1], RGB[i-1][2])+RGB[i][0], min(RGB[i-1][0], RGB[i-1][2])+RGB[i][1], min(RGB[i-1][0], RGB[i-1][1])+RGB[i][2]]

print(min(RGB[-1]))

'''
3
26 40 83
49 60 57
13 89 99
'''

```

오늘은 간만에 짧은 코드!

동적 계획법 문제를 오랜만에 풀어보았다.

최솟값을 구하는 문제. dp라는 새로운 배열에 적지 않고 입력으로 받은 RGB리스트를 그대로 더해가며 갱신하는 방식으로 풀었다.

우선 바로 앞의 RGB와 겹치면 안되면서 최소를 선택해야 한다. 그래서 반복문은 인덱스 1번부터 시작한다.

1~ 각 RGB칸에 선택 됐을 시 최소값으르 넣는데, R일 경우, 앞의 칸의 G,B 중 최소를 고른 뒤 현재 R칸 더해서 넣어준다.

    26 40 83
    49+40 60+26 57+26 이 된다. 해당 칸에 앞에서 올 수 있는 최소 값을 더해준다.

이렇게 하면 맨 마지막 칸의 RGB 색 중에서 최소 값을 고르면 된다.
