---
layout: post
title:  "Baekjoon 알고리즘 50"
date:   2021-01-28 23:55 +0530
categories: python
---

알고리즘 풀기 62일차

그리드 문제를 풀어보았습니다.

:)


- #2217     로브

N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.

하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.

각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.

```python

n = int(input())
rope = []
value=[]
for i in range(n):
     rope.append(int(input()))
rope.sort(reverse = True)
for i in range(n):
     value.append(rope[i]*(i+1))

print(max(value))

```

단순히 제일 작은 min에서 n을 곱해주는 것을 생각했는데 틀렸다.

너무 단순히 예제만 보고 짠,,,

생각해보니 10, 15, 20이 있다면 로브 한개론 20, 두개론 30, 세개로도 30. 작은 로브가 굳이 안 필요할 수도 있다.

이렇게 생각을 해서 정리해보니 큰 수부터 내림차 정렬 후 로브 개수 n을 늘려나갈때 내림차한 배열에 n개씩 곱했을때의 최댓값을 구하면 된다.

100,80,60,40,30 이 입력으로 내림차 해주고, 로브가 한개라면 당연히 100에 거는게 최대, 두개라면 80씩 두번 걸 수 있으니 160, 로브가 세개면 리스트의 세번째 60에 *3 ,,, 이런 식.
