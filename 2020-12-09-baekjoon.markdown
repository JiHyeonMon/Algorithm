---
layout: post
title:  "Baekjoon 알고리즘 26"
date:   2020-12-09 02:30 +0530
categories: python
---

알고리즘 풀기 37일차

:)


- #1463     1로 만들기

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.


1. X가 3으로 나누어 떨어지면, 3으로 나눈다.

2. X가 2로 나누어 떨어지면, 2로 나눈다.

3. 1을 뺀다.


정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.


```python
#1차 실패

n=int(input())
cnt = 0

while n!=1:
     if n%3==0:
          n=n//3
     elif n%2==0:
          n=n//2
     else:
          n-=1

     if n==1:
          if cnt==0:
               cnt=1
          break
     
     cnt+=1

print(cnt)

```

문제만 읽고 단순하게 접근한 풀이다. 조건들은 충족하지만 최소로 해야하는 경우를 생각하지 못한다. 

( 그래도 나름 최소값을 빨리 찾기위해 3 (큰 수부터) 확인해서 내려온다. )



```python
#2차

'''
1=1
2=1
3=1
4=2 *2 *2 / *3 +1
5=3 *2 *2 +1 / *3 *2 +1
6=2 *3 *3
7=3 *3 *2 +1
8=4 *3 *2 +1 +1
'''

n = int(input())
cnt= 0
tmp = 1

while tmp>=n:
     tmp*=3
     cnt+=1

if tmp==n:
     cnt-=1
else: # *2 or +1

```

두번째로는 역으로 생각해서 1부터 *3, *2, +1만 사용해서 n까지 갈 수 있을 때 최소를 생각해봤다.

이 경우 무조건 큰 수 (3)을 곱해서 가는게 최소 방법이여서 3을 최대한 많이 쓰는 걸로 생각을 했는데, 3의 최대 구하는 while과 이후 2와 +1까지의 또한 반복이 될 거 같아서 너무 복잡도가 커지는 느낌이 들었다. 



```python

#3차 성공

n=int(input())
 
dp=[ 0 for _ in range(n+2) ]
dp[2]=1
 
for i in range(2, len(dp)):
 
    dp[i]=dp[i-1]+1
 
    if i%3==0:
        if dp[i]> dp[int(i/3)]+1:
            dp[i]=dp[int(i/3)]+1
    if i%2==0:
        if dp[i]> dp[int(i/2)]+1:
            dp[i] =dp[int(i/2)]+1
 
print(dp[n])

```

풀이를 찾아봤다! 사람들은 정말 똑똑이다.

일단 최소값 + *3/*2/+1이니 입력 n까지 배열을 만들어서 최소값을 차근차근 넣어간다. 

일단 인덱스 i에서는 i-1의 최소값에 +1이 기본인데, *3이나 *2가 가능하니 i의 /3, /2의 값이 i-1에서의 값보다 작다면 그걸로 바꿔주고 카운트 1을 더해주면 된다.

---

어제 못푼 문제도 그렇고 이제부턴 규칙을 찾아 식을 일반화한 점화식을 찾아서 푸는 것 같은데,,,머리가 잘 안돌아가서 주먹구구식으로 풀다보니 계속 틀려버린다...

코드는 어렵지 않지만, 규칙 찾기가 참 어렵구나 싶다.