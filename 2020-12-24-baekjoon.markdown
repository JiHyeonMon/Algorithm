---
layout: post
title:  "Baekjoon 알고리즘 32"
date:   2020-12-24 20:05 +0530
categories: python
---

알고리즘 풀기 44일차

일주일에 한번은 반성문을 쓰는 듯한 느낌,,,ㅎ

:)


- #11722     가장 긴 감소하는 수열

수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 30, 10, 20, 20, 10} 인 경우에 가장 긴 감소하는 부분 수열은 A = {10, 30, 10, 20, 20, 10}  이고, 길이는 3이다.

```python

n = int(input())
num = list(map(int, input().split()))

dp = [1 for i in range(n)]

for i in range(n):
    for j in range(i):
        if num[i] < num[j]:
            dp[i] = max(dp[i], dp[j] + 1)
            
print(max(dp))

```

i가 커지면서 i까지 인덱스 중 길이를 구하는 방식으로 코드를 실행시키면 [1, 1, 2, 2, 2, 3] 이렇게 리스트가 쌓인다.
마지막 수 까지 돌면 마지막 인덱스까지의 최대 길이라 3이 된다.

우선 1로 다 초기화한다. (왜냐면 감소안해도 자기자신은 포함되기 때문에 최소값이 1)

i가 2라면 10,30까지를 보는데 감소가 없기 때문에 1이 들어간다.

i가 3이라면 10,30,20을 보는데 30->20으로 감소하기 때문에 2가 들어간다.

이렇게 마지막까지 가면 30->20->10 총 3번 감소하는 패턴으로 3이 들어가고 3을 출력한다.


풀이는 참고했다. 처음엔 그냥 감소하는거 찾으면 되는거 아닌가 했는데, 역시 그렇게 단순하게 생각하면 안됐다. 

i를 증가시키며 최대값(길이가 제일 긴 것)을 찾아야하기 때문에 앞서 큰 값이 발견되면(더 길어질 수 있음) 원래의 현재값 길이랑 그 최댓값이 있는 자리까지의 길이랑 비교해서 더 큰 값을 최대 길이로 넣어준다.
(앞서 큰 값을 만나면 1더해줘 길이를 늘려나간다.)



